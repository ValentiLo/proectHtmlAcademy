<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6.10. Поиск в деревьях</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>6.10. Поиск в деревьях</h1>
    <p>В HTML все элементы, кроме document, являются вложенными: head и body вложены в document, элементы списка li могут быть вложены в элемент нумерованного списка ol или неупорядоченного списка ul. Структура, которую представляет HTML-документ, а соответственно и DOM, является деревом.</p>
    <p>Когда возникает необходимость найти элемент в древовидной структуре, сделать это можно двумя способами:</p>
    <ol>
        <li>Поиск в глубину (DFS — Depth-First Search)</li>
        <li>Поиск в ширину (BFS — Breadth-First Search)</li>
    </ol>
    <p>Хотя в JavaScript для поиска элемента используется первый способ — поиск в глубину, знать оба полезно.</p>
    <p>Для разбора каждого из подходов возьмём следующую древовидную структуру, которая представляет HTML-документ. Соответственно, каждый узел — это HTML-элемент.</p>
    <p><figure><img src="04-03-dom-tree.png" alt="Рисунок 1. Схема DOM-дерева"><figcaption>Рисунок 1. Схема DOM-дерева</figcaption></figure></p>
    <p>Допустим, наша задача — найти ссылку, то есть HTML-элемент a. И поиск в глубину, и поиск в ширину начинается с узла document. В document мы найдём единственного ребёнка — узел html. Так как ни document, ни html ссылками не являются, мы идём дальше и находим не один, а нескольких дочерних элементов. Разница между поиском в глубину и поиском в ширину заключается в том, каким образом мы продолжим поиск.</p>
    <h2>Поиск в глубину</h2>
    <p>Мы находим одного из детей html — элемент head. Нам опять не повезло найти ссылку, поэтому пойдём вглубь, то есть в единственного ребёнка head — элемент title. Title также не соответствует требованиям поиска, и к тому же не имеет дочерних элементов.</p>
    <p><figure><img src="04-03-depth-search.gif" alt="Рисунок 2. Поиск в глубину"><figcaption>Рисунок 2. Поиск в глубину</figcaption></figure></p>
    <p>Мы упёрлись в тупик. Самое время вернуться назад, в html, и пойти по второму доступному пути — в элемент body. Далее, по такой же цепочке, мы найдём элементы h1 и, наконец, a.</p>
    <p><figure><img src="04-03-depth-search2.gif" alt="Рисунок 3. Поиск в глубину, продолжение"><figcaption>Рисунок 3. Поиск в глубину, продолжение</figcaption></figure></p>
    <p>Когда имеется несколько доступных путей поиска, при поиске в глубину мы исследуем каждый из них до тех пор, пока не сталкиваемся с тупиком. Из тупика мы возвращаемся на последнюю развилку, исследуем её и так далее.</p>
    <h2>Поиск в ширину</h2>
    <p>Теперь попробуем снова найти ссылку, но уже используя поиск в ширину. Вспомним, что начинаем мы из document, проваливаемся в html и сталкиваемся с распутьем.</p>
    <p>В отличие от поиска в глубину, поиск в ширину сначала проверит всех детей элемента html, то есть head и body, на соответствие элементу-ссылке. Не найдя то, что ищет, он пойдёт в их непосредственно дочерние элементы и проверит их. Данный паттерн, проверка слой за слоем — это принцип работы поиска в ширину.</p>
    <p><figure><img src="04-03-breadth-search.gif" alt="Рисунок 4. Поиск в ширину"><figcaption>Рисунок 4. Поиск в ширину</figcaption></figure></p>
    <h1>Резюме</h1>
    <p>Поиск в глубину и поиск в ширину — два подхода к обходу древовидных структур. Первый находит узел и проваливается в него, даже если у него есть соседи, которых можно проверить. Поиск в ширину, с другой стороны, сначала проверит все узлы одного уровня, и лишь затем будет спускаться в их непосредственных детей. JavaScript для обхода DOM использует поиск в глубину.</p>
   
<p><a href="index.html">На главную</a></p>  
</body>
</html>